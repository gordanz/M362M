---
title: "for_loops"
output: html_document
---
Part 1: The function `cumavg` can be written in many ways; the one in the solution is sleek because it does not use any `for` loops (which we are yet to introduce in these notes). It is also faster than the other two implementations below.  It relies on the fact that many natural operations in R are already vectorized. The builtin function `cumsum` performs most of the work - once we have partial sums, we simply need to divide each one of them by the index of its position in the vector. If you wanted to use `for` loops and not rely on the function `cumsum`, you could write something like this:
```{r}
cumavg = function(x) {
   out =  numeric(length(x))
   for (i in 1:length(x)) {
      p = 0
      for (j in 1:i) {
         p = p + x[j]
      }
      out[i] = p / i
   }
   return(out)
}
```
The statement `out = numeric(length(x))` is there to ask R to reserve enough room (memory) for a numeric vector the same size as `x`. It is not necessary, but it is a good idea to get into the habit of doing it because is makes your code both faster and easier to read. 

Here is another way, using the `sum` function:
```{r}
cumavg = function(x) {
   out = numeric(0)
   for (i in 1:length(x)) {
      out = c(out, sum(x[1:i]) / i)
   }
   return(out)
}
```
The line `out = c(out, sum(x[1:i]) / i)` appends the value `sum(x[1:i]) / i` to the end of the vector `out`. Note that `x[1:i]` is the vector `x` indexed by the sequence `1:i` (i.e., `1,2,...,i`), which is nothing other than the vector containing the first `i` elements of `x`. We also "pre-declared" the vector `out` in the statement `out = numeric(0)'. This time we only made sure that out is an empty numerical vector because of the way we build it incrementally. This is, in general, not a very efficient way of doing things, but it will do just fine for small vectors. 
