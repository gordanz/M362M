<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="2.2 Monte Carlo | Lecture notes for &quot;Introduction to Stochastic Processes&quot;" />
<meta property="og:type" content="book" />


<meta property="og:description" content="A set of lecture notes for M362M: Introduction to Stochastic Processes" />
<meta name="github-repo" content="gordanz/M362M" />

<meta name="author" content="Gordan Zitkovic" />


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<meta name="description" content="A set of lecture notes for M362M: Introduction to Stochastic Processes">

<title>2.2 Monte Carlo | Lecture notes for &quot;Introduction to Stochastic Processes&quot;</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/united.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="libs/navigation-1.1/tabsets.js"></script>
<script src="libs/kePrint-0.0.1/kePrint.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
</style>
</head>

<body>

<div class="container-fluid main-container">


<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#preface">Preface</a></li>
<li class="has-sub"><a href="1-intro.html#intro"><span class="toc-section-number">1</span> An intro to R and RStudio</a><ul>
<li><a href="1-1-setting-up-an-r-environment-on-your-computer.html#setting-up-an-r-environment-on-your-computer"><span class="toc-section-number">1.1</span> Setting up an R environment on your computer</a></li>
<li><a href="1-2-learning-the-very-basics-of-r.html#learning-the-very-basics-of-r"><span class="toc-section-number">1.2</span> Learning the very basics of R</a></li>
<li><a href="1-3-r-notebooks-or-how-to-submit-your-hw-assignments-and-exams.html#r-notebooks-or-how-to-submit-your-hw-assignments-and-exams"><span class="toc-section-number">1.3</span> R Notebooks or <em>How to submit your HW assignments and exams</em></a></li>
<li><a href="1-4-problems.html#problems"><span class="toc-section-number">1.4</span> Problems</a></li>
</ul></li>
<li class="part"><span><b>I Probability and Simulation</b></span></li>
<li class="has-sub"><a href="2-simulation-of-random-variables-and-monte-carlo.html#simulation-of-random-variables-and-monte-carlo"><span class="toc-section-number">2</span> Simulation of Random Variables and Monte Carlo</a><ul>
<li><a href="2-1-how-to-simulate-some-common-probability-distributions.html#how-to-simulate-some-common-probability-distributions"><span class="toc-section-number">2.1</span> How to simulate some common probability distributions</a></li>
<li><a href="2-2-monte-carlo.html#monte-carlo"><span class="toc-section-number">2.2</span> Monte Carlo</a></li>
<li><a href="2-3-conditional-probability-and-independence-.html#conditional-probability-and-independence."><span class="toc-section-number">2.3</span> Conditional probability and independence.</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="monte-carlo" class="section level2">
<h2><span class="header-section-number">2.2</span> Monte Carlo</h2>

<div class="exercise">
<span id="exr:unnamed-chunk-36" class="exercise"><strong>Problem 2.6  </strong></span>Use Monte Carlo to estimate the expected value of the exponential random variable with parameter <span class="math inline">\(\lambda= 4\)</span> using <span class="math inline">\(n=10\)</span>, <span class="math inline">\(n=1,000\)</span> and <span class="math inline">\(1,000,000\)</span> simulations. Compare to the exact value.
</div>

<p><strong>Solution:</strong></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">rexp</span>(<span class="dv">10</span>, <span class="dt">rate=</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="co">#R&gt; [1] 0.1779768</span></a></code></pre></div>
<p>For an exponential random variable with parameter <span class="math inline">\(\lambda\)</span>, the expected value is
<span class="math inline">\(1/\lambda\)</span>; in this case <span class="math inline">\(0.25\)</span>. The error made was 0.072023 for <span class="math inline">\(n=10\)</span> simulations.
We increase the numbner of simulations to <span class="math inline">\(n=1000\)</span> and get a better result</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">rexp</span>(<span class="dv">1000</span>, <span class="dt">rate=</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="co">#R&gt; [1] 0.2564643</span></a></code></pre></div>
<p>with (smaller) error -0.0064643. Finally, let’s try <span class="math inline">\(n=1,000,000\)</span>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">rexp</span>(<span class="dv">1000000</span>, <span class="dt">rate=</span><span class="dv">4</span>)</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="co">#R&gt; [1] 0.250381</span></a></code></pre></div>
<p>The error is even smaller -0.00038101.</p>
<p>This can be obtained quite easily by integration (by parts):
<span class="math display">\[ {\mathbb{E}}[X] = \int_{-\infty}^{\infty} x f(x)\, dx = \int_0^{\infty} x \lambda e^{-\lambda x}\, dx = \tfrac{1}{\lambda}\]</span></p>
<p><strong>Comments:</strong></p>
<p><em>R.</em> The only new thing here is the command <code>mean</code> which computes the mean of vector.</p>
<p><em>Math.</em> There is a lot going on here conceptually. This is the first time we used the Monte Carlo method. It is an incredibly method, as you will keep being reminded throughout this class. The idea behind it is simple, and it is based on the <em>Law of large numbers</em>:</p>
<p><strong>Theorem</strong> Let <span class="math inline">\(X_1,X_2, \dots\)</span> be an independent sequence of random variables with the same distribution, for which the expected value can be computed. Then
<span class="math display">\[ \tfrac{1}{n} \Big( X_1+X_2+\dots+X_n\Big) \to {\mathbb{E}}[X_1] \text{ as } n\to\infty\]</span>
The idea behind Monte Carlo is to turn this theorem “upside down”. The goal is to compute <span class="math inline">\({\mathbb{E}}[X_1]\)</span>, and uses a supply of random numbers, each of which comes from the same distribution to accomplish that. The random number generator inside <code>rexp</code> gives us a supply of numbers (stored in the vector <code>x</code>) and all we have to do is compute their average. This gives us the left-hand side of the formula above, and, if <span class="math inline">\(n\)</span> is large enough, we hope that the this average does not differ too much from its theoretical limit. As <span class="math inline">\(n\)</span> gets larger, we expect better and better results. That is why your error above gets smaller as <span class="math inline">\(n\)</span> increases.</p>
<p>It looks like Monte Carlo can only be used to compute the expected value of a random variable, which does not seem like such a bit deal. It is! You will see in the sequel that almost anything can be written as the expected value of <em>some</em> random variable.</p>

<div class="exercise">
<span id="exr:unnamed-chunk-40" class="exercise"><strong>Problem 2.7  </strong></span>Use Monte Carlo to estimate <span class="math inline">\({\mathbb{E}}[X^2]\)</span>, where <span class="math inline">\(X\)</span> is a standard normal random variable. Do the same thing when <span class="math inline">\(X\)</span> is geometrically distributed with prameter <span class="math inline">\(p=0.5\)</span>.
</div>

<p><strong>Solution.</strong>
When <span class="math inline">\(X\)</span> is standard normal <span class="math inline">\(Y=X^2\)</span> has a <span class="math inline">\(\chi^2\)</span> distribution with one degree of freedom:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">y =<span class="st"> </span><span class="kw">rchisq</span>(<span class="dv">100000</span>,<span class="dt">df=</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="kw">mean</span>(x)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="co">#R&gt; [1] 0.250381</span></a></code></pre></div>
<p>In the second case, we do not know the distribution of <span class="math inline">\(X^2\)</span>, but can still do the following:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">rgeom</span>(<span class="dv">100000</span>, <span class="dt">prob=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">y &lt;-<span class="st"> </span>x<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="kw">mean</span>(y)</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="co">#R&gt; [1] 2.99152</span></a></code></pre></div>
<p><strong>Comments:</strong></p>
<p><em>Math+R.</em> We are asked to compute <span class="math inline">\({\mathbb{E}}[ X^2]\)</span>, which can be interpreted in two ways. First, we can think of <span class="math inline">\(Y=X^2\)</span> as a random variable in its own and try to take draws from the distribution of <span class="math inline">\(Y\)</span>. In the case of the normal distribution, the distribution of <span class="math inline">\(Y\)</span> is known - it happens to be a <span class="math inline">\(\chi^2\)</span>-distribution with a single degree of freedom (don’t worry if you never heard of it). We can simulate it in R by using its R name <code>chisq</code> and
get a number close to the exact value of <span class="math inline">\(1\)</span>.</p>
<p>The case of a geometric distribution is seemingly more difficult, because we do not know what the distribution of <span class="math inline">\(Y=X^2\)</span> is and there is no corresponding R name to put the prefix <code>r</code> in front of. What makes the simulation possible is the fact that <span class="math inline">\(Y\)</span> is a <em>transformation</em> of
a random variable we know how to simulate. In that case, we simply simulate the required number of draws <code>x</code> from the geometric distribution (using <code>rgeom</code>) and then apply the transformation <span class="math inline">\(x \mapsto x^2\)</span> to the result. The transformed vector <code>y</code> is then nothing but the sequence of draws from the distribution of <span class="math inline">\(X^2\)</span>. Btw, we could have done the same thing in the case of the normal random variable, too - there was no need to recoqnize its square as a <span class="math inline">\(\chi^2\)</span> random variable:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100000</span>)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">y &lt;-<span class="st"> </span>x<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="kw">mean</span>(y)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="co">#R&gt; [1] 1.008819</span></a></code></pre></div>
<p>The idea described above is one of main advantages of the Monte Carlo technique: if you know how to simulated a random variable, you also know how to simulated any (deterministic) function of it. That fact will come into its own a bit later when we start working with several random variables and stochastic processes, but it can be very helpful even in the case of a single random variable, as you will see in the next problem.</p>

<div class="exercise">
<span id="exr:unnamed-chunk-44" class="exercise"><strong>Problem 2.8  </strong></span>Let <span class="math inline">\(X\)</span> be a standard normal random variable. Use Monte Carlo to estimate the probability <span class="math inline">\({\mathbb{P}}[ X &gt; 1 ]\)</span>. Compare to the exact value.
</div>

<p><strong>Solution:</strong>
The estimated probability:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100000</span>)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">y &lt;-<span class="st"> </span>x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">(<span class="dt">p_est =</span> <span class="kw">mean</span>(y))</a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="co">#R&gt; [1] 0.15732</span></a></code></pre></div>
<p>The exact probability:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">pnorm</span>(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="co">#R&gt; [1] 0.1586553</span></a></code></pre></div>
<p>The error is -0.0013353.</p>
<p><strong>Comments:</strong></p>
<p><em>R.</em> In R, the symbol <code>&gt;</code> is an operation, which returns a boolean (<code>TRUE</code> or <code>FALSE</code>) value. For example:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="dv">1</span><span class="op">&gt;</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="co">#R&gt; [1] FALSE</span></a></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="dv">5</span><span class="op">^</span><span class="dv">2</span><span class="op">&gt;</span><span class="dv">20</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="co">#R&gt; [1] TRUE</span></a></code></pre></div>
<p>It works with vectors, too, but now the output is a vector of boolean values:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">5</span>,<span class="op">-</span><span class="dv">4</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">x<span class="op">&gt;</span>y</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"><span class="co">#R&gt; [1] FALSE  TRUE  TRUE</span></a></code></pre></div>
<p>You can even compare a vector and a scalar:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">x<span class="op">&gt;</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="co">#R&gt;  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE</span></a></code></pre></div>
Therefore, the vector <code>y</code> in the solution is a vector of length <span class="math inline">\(100000\)</span> whose elements are either <code>TRUE</code> or <code>FALSE</code>; here are the first 5 rows of the “spreadsheet” (called a <strong>data frame</strong> or a <strong>tibble</strong> in R) with columns <code>x</code> and <code>y</code> from our solution:
<table class="table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:right;">
x
</th>
<th style="text-align:left;">
y
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
1.9493
</td>
<td style="text-align:left;">
FALSE
</td>
</tr>
<tr>
<td style="text-align:right;">
-1.1015
</td>
<td style="text-align:left;">
TRUE
</td>
</tr>
<tr>
<td style="text-align:right;">
1.0448
</td>
<td style="text-align:left;">
TRUE
</td>
</tr>
<tr>
<td style="text-align:right;">
-0.1384
</td>
<td style="text-align:left;">
TRUE
</td>
</tr>
<tr>
<td style="text-align:right;">
-0.2573
</td>
<td style="text-align:left;">
TRUE
</td>
</tr>
</tbody>
</table>
<p>Finally, <code>z</code> contains the <code>mean</code> of <code>y</code>. How do you compute a mean of boolean values? In R (and many other languages) <code>TRUE</code> and <code>FALSE</code> have default numerical values, usually <span class="math inline">\(1\)</span> and <span class="math inline">\(0\)</span>. This way, when <span class="math inline">\(R\)</span> is asked to compute the <code>sum</code> of a boolean vector it will effectively count the number of values which are <code>TRUE</code>. Similarly, the <code>mean</code> is the relative proportion of <code>TRUE</code> values.</p>
<em>Math.</em>
We computed the <strong>proportion</strong> of the “times” <span class="math inline">\(X&gt;1\)</span> (among many simulations of <span class="math inline">\(X\)</span>) and used it to approximate the <strong>probability</strong> <span class="math inline">\({\mathbb{P}}[ X&gt;1]\)</span>. More formally,
we started from a random variable <span class="math inline">\(X\)</span> with a normal distribution and then transformed it into another random variable, <span class="math inline">\(Y\)</span>, by setting <span class="math inline">\(Y=1\)</span> whenever <span class="math inline">\(X&gt;1\)</span> and <span class="math inline">\(0\)</span> otherwise. This is often written as follows
<span class="math display">\[ Y = \begin{cases} 1, &amp; X&gt;1 \\ 0, &amp; X\leq 1.\end{cases}\]</span>
The random variable <span class="math inline">\(Y\)</span> is very special - it can only take values <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> (i.e., its support is <span class="math inline">\(\{0,1\}\)</span>). Such random variables are called <strong>indicator random variables</strong>, and their distribution, called the <strong>Bernoulli distribution</strong>, always looks like this:
<table class="table" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
0
</th>
<th style="text-align:left;">
1
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1-p
</td>
<td style="text-align:left;">
p
</td>
</tr>
</tbody>
</table>
<p>for some <span class="math inline">\(p \in [0,1]\)</span>. The parameter <span class="math inline">\(p\)</span> is nothing but the probability <span class="math inline">\({\mathbb{P}}[Y=1]\)</span>.</p>
<p>So why did we decide to transform <span class="math inline">\(X\)</span> into <span class="math inline">\(Y\)</span>? Because of the following simple fact:
<span class="math display">\[ {\mathbb{E}}[ Y] = 1 \times p + 0 \times (1-p) = p.\]</span>
The expected value of an indicator is the probability <span class="math inline">\(p\)</span>, and we know that we can use Monte Carlo whenever we can express the quantity we are computing as an expectated value of a random variable we know how to simulate.</p>

<div class="exercise">
<span id="exr:unnamed-chunk-53" class="exercise"><strong>Problem 2.9  </strong></span>Use Monte Carlo to Estimate the value of <span class="math inline">\(\pi\)</span> and compute the error.
</div>

<p><strong>Solution.</strong></p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1">nsim &lt;-<span class="st"> </span><span class="dv">1000000</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">x &lt;-<span class="st">  </span><span class="kw">runif</span>(nsim, <span class="dv">-1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">y &lt;-<span class="st">  </span><span class="kw">runif</span>(nsim, <span class="dv">-1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">z &lt;-<span class="st"> </span>(x<span class="op">^</span><span class="dv">2</span><span class="op">+</span>y<span class="op">^</span><span class="dv">2</span>) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5">(pi_est &lt;-<span class="st"> </span><span class="dv">4</span><span class="op">*</span><span class="st"> </span><span class="kw">mean</span>(z))</a>
<a class="sourceLine" id="cb34-6" data-line-number="6"><span class="co">#R&gt; [1] 3.141728</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7">(err &lt;-<span class="st"> </span>pi_est <span class="op">-</span><span class="st"> </span>pi)</a>
<a class="sourceLine" id="cb34-8" data-line-number="8"><span class="co">#R&gt; [1] 0.0001353464</span></a></code></pre></div>
<p>Since we know the “exact” value of <span class="math inline">\(\pi\)</span>, we can compute the error <code>{r} format(err, digits=5)</code>.</p>
<p><strong>Comments.</strong>:</p>
<p><em>Math.</em>
<img src="pics/mc_pi.gif" width="50%" style="float:right; padding:10px" style="display: block; margin: auto;" />
As we learned in the previous problem, probabilities of events can be computed using Monte Carlo, as long as we know how to simulate the underlying indicator random variable. In this case, we want to compute <span class="math inline">\(\pi\)</span>, so we would need to find a “situation” in which the probability of something is <span class="math inline">\(\pi\)</span>. Of course, <span class="math inline">\(\pi&gt;1\)</span>, so it cannot be a probability of anything, but <span class="math inline">\(\pi/4\)</span> can, and computing <span class="math inline">\(\pi/4\)</span> is as useful as computing <span class="math inline">\(\pi\)</span>. To create the required probabilistic “situation” we think of the geometric meaning of <span class="math inline">\(\pi\)</span>, and come up with the following scheme. Let <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> be two independent uniform random variables each with values between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>. We can think of the pair <span class="math inline">\((X,Y)\)</span> as a random point in the squre <span class="math inline">\([-1,1]\times [-1,1]\)</span>. This point will sometimes fall inside the unit circle, and sometimes it will not. What is the probability of hitting the circle? Well, since <span class="math inline">\((X,Y)\)</span> is uniformly distributed everywhere inside the square, this probability shoule be equal to the portion of the area of our square which belongs to the unit circle. The area of the square is <span class="math inline">\(4\)</span> and the area of the circle is <span class="math inline">\(\pi\)</span>, so the required probability is <span class="math inline">\(\pi/4\)</span>. Using the idea from the previous problem, we define the indicator random variable <span class="math inline">\(Z\)</span> as follows
<span class="math display">\[ Z = \begin{cases} 1 &amp; (X,Y) \text{ is inside the unit circle, } \\ 0 &amp; \text{ otherwise.}
\end{cases}
= \begin{cases} 1&amp; X^2+Y^2 &lt; 1, \\ 0 &amp; \text{ otherwise.} \end{cases}\]</span></p>

<div class="exercise">
<p><span id="exr:unnamed-chunk-56" class="exercise"><strong>Problem 2.10  </strong></span>1. Write an R function <code>cumavg</code> which computes the sequence of running averages of a vector, i.e., if the input is <span class="math inline">\(x=(x_1,x_2,x_3,\dots, x_n)\)</span>, the output should be
<span class="math display">\[ \Big(x_1, \frac{1}{2} (x_1+x_2), \frac{1}{3}(x_1+x_2+x_3), \dots, \frac{1}{n} (x_1+x_2+\dots+x_n)\Big).\]</span> Test it to check that it really works.</p>
<ol start="2" style="list-style-type: decimal">
<li>Apply <code>cumavg</code> to the vector <span class="math inline">\(4 z\)</span> from the previous problem and plot your results (use a smaller value for <code>nsim</code>. Maybe <span class="math inline">\(1000\)</span>.) Plot the values against their index. Add a read horizontal line at the level <span class="math inline">\(\pi\)</span>. Rerun the same code (including the simulation part) several times.
</div></li>
</ol>
<p><strong>Solution</strong></p>
<ol style="list-style-type: decimal">
<li></li>
</ol>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1">cumavg &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">   c &lt;-<span class="st"> </span><span class="kw">cumsum</span>(x)</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">   n &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">   <span class="kw">return</span>(c <span class="op">/</span><span class="st"> </span>n)</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb35-6" data-line-number="6">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">9</span>)</a>
<a class="sourceLine" id="cb35-7" data-line-number="7"><span class="kw">cumavg</span>(x)</a>
<a class="sourceLine" id="cb35-8" data-line-number="8"><span class="co">#R&gt; [1] 1 2 3 3 3 4</span></a></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li></li>
</ol>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1">nsim &lt;-<span class="st"> </span><span class="dv">1000</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">x &lt;-<span class="st">  </span><span class="kw">runif</span>(nsim, <span class="dv">-1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">y &lt;-<span class="st">  </span><span class="kw">runif</span>(nsim, <span class="dv">-1</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">z &lt;-<span class="st"> </span>(x <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>y <span class="op">^</span><span class="st"> </span><span class="dv">2</span>) <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5">pi_est =<span class="st"> </span><span class="kw">cumavg</span>(<span class="dv">4</span> <span class="op">*</span><span class="st"> </span>z)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6"><span class="kw">plot</span>(<span class="dv">1</span><span class="op">:</span>nsim, pi_est,</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">   <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>,</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">   <span class="dt">xlab =</span> <span class="st">&quot;number of simulations&quot;</span>,</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">   <span class="dt">ylab =</span> <span class="st">&quot;estimate of pi&quot;</span>,</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">   <span class="dt">main =</span> <span class="st">&quot;Computing pi by Monte Carlo&quot;</span></a>
<a class="sourceLine" id="cb36-11" data-line-number="11">)</a>
<a class="sourceLine" id="cb36-12" data-line-number="12"><span class="kw">abline</span>(pi, <span class="dv">0</span>,</a>
<a class="sourceLine" id="cb36-13" data-line-number="13">   <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-58-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Comments:</strong></p>
<p><em>R.</em></p>
<p>Part 1: The function <code>cumavg</code> can be written in many ways; the one in the solution is sleek because it does not use any <code>for</code> loops. It is also faster than the other two implementations below. It relies on the fact that many natural operatrions in R are already vectorizes. The builtin function <code>cumsum</code> performs most of the work - once we have partial sums, we simply need to divide each one of them by the index of its position in the vector. If you wanted to use <code>for</code> loops and not rely on the function <code>cumsum</code>, you could write something like this:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1">cumavg &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">   out &lt;-<span class="st">  </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">   <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">      p &lt;-<span class="st"> </span><span class="dv">0</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">      <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>i) {</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">         p =<span class="st"> </span>p <span class="op">+</span><span class="st"> </span>x[j]</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">      }</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">      out[i] =<span class="st"> </span>p <span class="op">/</span><span class="st"> </span>i</a>
<a class="sourceLine" id="cb37-9" data-line-number="9">   }</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">   <span class="kw">return</span>(out)</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">}</a></code></pre></div>
<p>The statement <code>out &lt;- numeric(length(x))</code> is there to ask R to reserve enough room (memory) for a numeric vector the same size as <code>x</code>. It is not neccessary, but it is a good idea to get into the habit of doing it because is makes your code both faster and easier to read.</p>
<p>Here is another way, using the <code>sum</code> function:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1">cumavg &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">   out =<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">   <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">      out =<span class="st"> </span><span class="kw">c</span>(out, <span class="kw">sum</span>(x[<span class="dv">1</span><span class="op">:</span>i]) <span class="op">/</span><span class="st"> </span>i)</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">   }</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">   <span class="kw">return</span>(out)</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">}</a></code></pre></div>
<p>The line <code>out = c(out, sum(x[1:i]) / i)</code> appends the value <code>sum(x[1:i]) / i</code> to the end of the vector <code>out</code>. Note that <code>x[1:i]</code> is the vector <code>x</code> indexed by the sequence <code>1:i</code> (i.e., <code>1,2,...,i</code>), which is nothing other than the vector containing the first <code>i</code> elements of <code>x</code>. We also “pre-declared” the vector <code>out</code> in the statement `out = numeric(0)’. This time we only made sure that out is an empty numerical vector because of the way we build it incrementally. This is, in general, not a very efficient way of doing things, but it will do just fine for small vectors.</p>
<p>Part 2. This course is not about R graphics, but I think it is a good idea to teach you how to make basic plots in R. This is what the functions <code>plot</code> and <code>abline</code> (and some others) do. I have already mentioned the fact that R has a number of high-quality graphics packages (like <code>ggplot2</code>), but the builtin R graphics is certainly good enough for “quick-and-dirty” plots.</p>
<p>The main purpose of the function <code>plot</code> is to plot scatterplots:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb39-2" data-line-number="2">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="kw">plot</span>(x,y)</a></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-61-1.png" width="672" style="display: block; margin: auto;" />
The corresponding entries of vectors <code>x</code> and <code>y</code> are paired (into <span class="math inline">\((1,2)\)</span>, <span class="math inline">\((3,1)\)</span>, <span class="math inline">\((4,5)\)</span> and <span class="math inline">\((7,5)\)</span> in this case) and these pairs are used as coordinates of points. By default, each point is marked by a small circle, but this, and many other things, can be adjusted by numerous additional arguments. One of such arguments is <code>type</code> which determins the type of the plot. We used <code>type=&quot;l&quot;</code> which tells R to join the points with straight lines:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">5</span>)</a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="kw">plot</span>(x,y, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>)</a></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-62-1.png" width="672" style="display: block; margin: auto;" />
The other arguments, <code>xlab</code>, <code>ylab</code> and <code>main</code> determine labels for axes and the entire plot. The function <code>abline(a,b)</code> adds a line <span class="math inline">\(y = a x + b\)</span> to an already existing plot. It is very useful in statistics if one wants to show the regression line superimposed on the scatterplot of data. Finally, the argument <code>col</code>, of course, determines the color of the line. To learn about various graphical parameters, type <code>?par</code>.</p>
<p><em>Math.</em></p>
<p>The conceptual reason for this exercise is to explore (numerically) the kinds of errors we make when we use Monte Carlo. Unlike the deterministic numerical procedures, Monte Carlo has a strange property that no bound on the error can be made with absolute certainty. Let me give you an example. Suppose that you have a biased coin, with the probabilty <span class="math inline">\(0.6\)</span> of heads and <span class="math inline">\(0.4\)</span> of tails. You don’t know this probability, and use a Monte Carlo technique to estimate it - you toss your coin <span class="math inline">\(1000\)</span> times and record the number of times you observe <span class="math inline">\(H\)</span>. The law of large numbers suggests that the relative frequency of heads is close to the true probability of <span class="math inline">\(H\)</span>. Indeed, you run a simulation</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">1234</span>)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">x &lt;-<span class="st"> </span><span class="kw">sample</span>( <span class="kw">c</span>(<span class="st">&quot;T&quot;</span>,<span class="st">&quot;H&quot;</span>), <span class="dv">1000</span>, <span class="dt">prob =</span> <span class="kw">c</span>(<span class="fl">0.4</span>, <span class="fl">0.6</span>), <span class="dt">replace =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">y &lt;-<span class="st"> </span>x <span class="op">==</span><span class="st"> &quot;H&quot;</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4"><span class="kw">mean</span>(y)</a>
<a class="sourceLine" id="cb41-5" data-line-number="5"><span class="co">#R&gt; [1] 0.594</span></a></code></pre></div>
<p>and get a pretty accurate estimate of <span class="math inline">\(0.594\)</span>. If you run the same code a few more times, you will get different estimates, but all of them will be close to <span class="math inline">\(0.6\)</span>. Theoretically, however, your simulation could have yielded <span class="math inline">\(1000\)</span> Hs, which would lead you to report <span class="math inline">\(p=1\)</span> as the Monte-Carlo estimate. The point is that even though such disasters are theoretically possible, they are exceedingly unlikely. The probability of getting all <span class="math inline">\(H\)</span> in <span class="math inline">\(1000\)</span> tosses of this coin is a number with more than <span class="math inline">\(500\)</span> zeros after the decimal point.</p>
<p>The take-home message is that even though there are no guarantees, Monte Carlo performs well vast majority of the time. The crucial ingredient, however, is the number of simulations. The plot you were asked to make illustrates exactly that. The function <code>cumavg</code> gives you a whole sequence of Monte-Carlo estimates of the same thing (the number <span class="math inline">\(\pi\)</span>) with different numbers of simulations <code>nsim</code>. For small values of <code>nsim</code> the error is typically very large (and very random). As the number of simulations grows, the situations stabilizes and the error decreases. Without going into the theory behind it, let me only mention is that in the majority of practical applications we have the following relationship:
<span class="math display">\[ error \sim \frac{1}{\sqrt{n}}.\]</span>
In words, if you want to double the precision, you need to quadruple the number of simulations. If you want an extra digit in your estimate, you need to multiply the number of simulations by <span class="math inline">\(100\)</span>. Instead of going further into the theory, here is an image where I superimposed <span class="math inline">\(40\)</span> plots like the one you were asked to produce (the red lines are <span class="math inline">\(\pm \frac{4}{\sqrt{n}}\)</span>):</p>
<p><img src="_main_files/figure-html/unnamed-chunk-64-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<p style="text-align: center;">
<a href="2-1-how-to-simulate-some-common-probability-distributions.html"><button class="btn btn-default">Previous</button></a>
<a href="https://github.com/gordanz/M362M/edit/master/02-simulation.Rmd"><button class="btn btn-default">Edit</button></a>
<a href="2-3-conditional-probability-and-independence-.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
